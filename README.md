# Frontend 

<details>

<summary><strong>debounce &#x26; throttle에 대한 설명</strong></summary>

**debounce**와 **throttle**은 이벤트 핸들러 너무 자주 실행되지 않도록 조절하는 기법이다.&#x20;

debounce는 이벤트가 연속적으로 발생할 때, 마지막 이벤트가 발생한 후 일정 시간이 지나야 이벤트 핸들러가 실행되는 방식이다.

Searchbar에서 사용자가 키를 입력할 때마다 검색 요청을 보내면 부하가 지나치게 커지기 때문에, 사용자가 입력을 멈춘 후 일정 시간이 지나면 검색 요청을 보내는 방식으로 디바운스를 적용할 수 있다.&#x20;

throttle은 일정 시간 간격 동안 발생한 이벤트 중 첫 번째 또는 마지막 이벤트만 처리하는 방식이다. 이벤트가 계속해서 발생하더라도 설정된 시간 동안 한 번만 이벤트 핸들러가 실행된다.&#x20;

무한 스크롤은 스크롤이 하단에 위치하게 된 순간 즉시 추가 데이터 요청을 수행하므로, 사용자에게 더 자연스러운 스크롤 경험을 제공할 수 있기 때문에 throttle을 사용하는 것이 더 적합하다.

</details>

<details>

<summary><strong>인터프리터 언어인 자바스크립트에서 어떻게 호이스팅이 가능할까?</strong></summary>

자바스크립트에서 호이스팅이 가능한 이유는 자바스크립트 엔진이 코드를 실행하기 전에 컴파일 단계와 실행 단계를 거치기 때문이다.

컴파일 단계에서 함수 및 변수 선언을 한 부분이 메모리에 할당되며 undefined로 초기화된다. 이후 실행 단계에서 코드가 진행되면서 실제 할당된 값이 대입된다.
실행 단계란 실제 코드가 실행되는 과정으로, 컴파일 단계에서 메모리에 할당된 변수와 함수가 실행된다. 여기서 변수가 할당된 값을 가지게 되고, 함수가 호출되면 그 안의 코드가 수행된다.

</details>

<details>
<summary><strong>클로저란?</strong></summary>

클로저는 함수가 선언될 때의 스코프를 기억하여, 함수가 생성된 이후에도 그 스코프에 접근할 수 있는 기능을 말한다.

클로저는 자바스크립트의 함수가 일급 객체라는 특성과 렉시컬 스코프의 조합으로 만들어진다. 

```
function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log('Outer Variable: ' + outerVariable);
    console.log('Inner Variable: ' + innerVariable);
  };
}

const newFunction = outerFunction('outside');
newFunction('inside'); 
```

`innerFunction`은 `outerFunction`의 내부에 정의되어 있다. `innerFunction`은 자신이 생성된 스코프(`outerFunction`의 스코프)를 기억하고 `outerFunction`의 호출이 완료된 이후에도 그 스코프에 접근할 수 있다.
이것이 클로저가 동작하는 방식이다.

클로저는 다음과 같은 상황에서 활용할 수 있다.

1. 외부에서 접근할 수 없는 비공개 변수와 함수를 만들 수 있으므로 데이터를 은닉하여 외부 접근을 막고 무결성을 유지할 수 있다.
2. 비동기 작업에서 이전의 실행 컨텍스트를 유지해야 할 때 유용하다. 콜백 함수가 비동기적으로 실행될 때, 클로저를 사용하면 함수 실행 시점의 변수를 참조할 수 있다.

```
function createLogger(name) {
  return function() {
    console.log(`Logger: ${name}`);
  };
}

const logger = createLogger('MyApp');
setTimeout(logger, 1000); // 1초 후에 'Logger: MyApp' 출력
```

3. 모듈 패턴은 특정 기능을 캡슐화하고, 외부에 공개하고자 하는 부분만 선택적으로 노출하여 코드의 응집력을 높이고, 유지보수성을 향상시키는 패턴이다.
클로저를 활용하면 필요한 함수와 데이터만 외부로 노출함으로써 모듈 패턴을 쉽게 구현할 수 있다.

</details>
<details>
<summary><strong>reflow와 repaint의 차이점은?</strong></summary>

`reflow`는 브라우저가 페이지의 레이아웃을 다시 계산하는 과정을 말한다. 

DOM의 구조가 변경되거나 CSS 스타일이 변경되면, 브라우저는 각 요소가 화면에 어떻게 배치될지 다시 계산해야 한다. 이 과정은 모든 자식 요소와 관련된 부모 요소까지 영향을 주기 때문에 비용이 많이 드는 작업이다. 

예를 들어, CSS에서 요소의 width나 height 속성을 변경하면, 브라우저는 해당 요소뿐만 아니라 연관된 모든 요소의 배치를 다시 계산해야 한다.

반면에, `repaint`는 요소의 모양이나 스타일이 변경될 때 발생한다. 요소의 레이아웃은 그대로이고, 색상이나 배경 등의 스타일만 변경되는 경우를 말합니다. 

`background-color` 같은 속성을 예로 들면, 브라우저는 요소의 모양만 다시 그리면 되기 때문에 `reflow`보다는 비용이 덜 들지만, 여전히 성능에 영향을 줄 수 있다.

`reflow`는 레이아웃을 다시 계산하는 과정이고, `repaint`는 그 계산 결과를 화면에 다시 그리는 과정이다. 이 둘을 잘 이해하고 관리한다면 성능 최적화에 큰 도움이 됩니다.

1. reflow를 유발하는 CSS 속성 사용을 최소화: width, height, margin, padding, border 등의 속성은 요소의 레이아웃을 다시 계산하게 하므로 reflow를 일으킵니다. 가능한 한 미리 CSS에서 스타일을 설정해 초기 로드 시에만 계산이 이루어지도록 하고, 이후에는 가능한 변경을 지양한다.

2. CSS 애니메이션 최적화: 애니메이션에 transform과 opacity 속성만을 사용하는 것이 성능에 유리하다. 이 두 속성은 GPU 가속을 사용할 수 있어 reflow를 일으키지 않고 repaint만 발생시키므로 CPU 자원을 적게 사용한다.

3. `will-change`: CSS의 `will-change` 속성을 사용하여 브라우저에 특정 요소가 변경될 것이라고 미리 알려줄 수 있다. 예를 들어, `will-change: transform`으로 미리 GPU에서 요소를 준비하게 하여 `reflow` 및 `repaint`에 미치는 영향을 줄일 수 있다. 하지만 `will-change` 속성은 너무 자주 사용하면 메모리 낭비가 발생하므로 필요한 요소에만 적용해야 한다.
</details>
<details>
<summary><strong>웹접근성의 개념과 개선 방법은?</strong></summary>

웹 접근성은 장애인과 고령자 등 신체적 제약이 있는 사용자를 포함해, 모든 사용자가 웹 페이지를 동등하게 이용할 수 있도록 보장하는 개념이다. 네트워크 속도가 느리거나 밝은 햇빛 아래 화면을 보는 등 일상적인 제약 상황에서도, 모든 사용자가 제약 없이 웹을 사용할 수 있도록 하는 것이 웹 접근성의 궁극적인 목표이다.

웹 접근성 개선에는 다양한 방법이 있다.
1. 단순하고 명확한 구조의 HTML과 시맨틱 태그
: 시맨틱 태그는 웹 페이지의 구조와 의미를 명확하게 전달해 스크린 리더가 컨텐츠를 쉽게 이해하도록 도와준다,

2. ARIA 속성을 활용하여 스크린 리더가 동적 컨텐츠나 복잡한 UI 요소를 올바르게 인식할 수 있게 만들 수 있음

3. 키보드로도 페이지를 탐색할 수 있도록 포커스를 명확히 지정하여 키보드 사용자가 필요한 정보에 접근하기 쉽게 해야함

</details>
<details>
<summary><strong>SSR이란?</strong></summary>

SSR이란 서버에서 완성된 정적 HTML을 클라이언트에 내려주는 방식이다. 클라이언트 측에서는 해당 HTML을 파싱하여 화면을 그리게 된다.

반면, CSR 방식은 브라우저가 서버로부터 비어있는 HTML을 받아온 후, 필요한 자바스크립트 번들을 다운로드 하고 번들을 실행하여 동적으로 컨텐츠를 채우는 방식이다.

SSR은 다음과 같은 장점을 가지고 있다.
: 화면이 동적으로 그려지는 CSR에 비해 크롤러가 컨텐츠를 쉽게 인식하고, 초기 로드가 상대적으로 빨라 우선순위가 부여되어 상위에 노출될 가능성이 높아지기 때문에 SEO 측면에서 유리하다.
블로그나 커머스 등 SEO가 중요한 웹 애플리케이션에 적합하다.
뿐만 아니라, CSR과 달리 SSR에서는 번들을 다운로드 받거나 번들을 실행하여 동적으로 화면을 그려낼 필요가 없기 때문에 사용자가 빠른 초기 로딩 속도를 경험할 수 있다.

하지만 SSR은 이러한 한계점이 존재한다.
전통적인 SSR 방식은 클라이언트 사이드 라우팅이 불가능하기 때문에 빠르고 매끄러운 페이지 전환 경험을 제공하기 어렵다.
또한, 단순히 정적인 리소스를 내려주는 것이 아니라, 요청 시마다 페이지를 동적으로 구성해서 내려주어야 하는 경우에는 서버 비용이 증가할 수 있다는 단점이 있다.
</details>

<details><summary><strong>E2E 테스트란?</strong></summary>

프론트엔드에서 E2E 테스트는 애플리케이션의 사용자 경험을 처음부터 끝까지 시뮬레이션하여 테스트하는 방식이다.
단위 테스트나 통합 테스트와 달리, E2E 테스트는 사용자 관점에서 전체 애플리케이션이 의도한 대로 작동하는지 검증한다.
브라우저 환경에서 실제 사용자 동작을 흉내내어 다양한 시나리오를 테스트 하며, 버튼 클릭, 페이지 이동, 데이터 입력 등을 포함한다.

E2E 테스트를 진행하면 사용자와 동일한 방식으로 애플리케이션을 테스트하므로, 사용자에게 직접적인 영향을 미치는 오류를 조기에 발견할 수 있다. 
: E2E 테스트는 중요한 사용자 흐름이나 비즈니스 로직이 포함된 페이지에 적용하면 효과적이다.

유닛 테스트로도 충분히 안정성을 높일 수 있지 않을까?

유닛 테스트는 개별적인 코드 조각이 제대로 작동하는지 확인하지만, 전체 시스템의 흐름과 사용자가 실제로 겪는 경험을 확인 하지 않는다.

반면, E2E테스트는 애플리케이션을 사용자 관점에서 처음부터 끝까지 검사하여, 모든 시스템이 통합적으로 잘 작동하는지 확인한다. UI 상호작용, API 호출, 화면 전환 등 여러 구성 요소가 함께 작동하는
과정에서 발생할 수 있는 문제를 탐지할 수 있다. E2E 테스트를 통해 사용자가 실제로 겪게 될 시나리오를 점검함으로써, 전체 시스템 관점에서의 오류를 조기에 발견할 수 있다.

따라서 유닛 테스트와 E2E 테스트를 상호 보완적으로 함께 활용하는 것이 좋다. 유닛 테스트는 개별 컴포넌트를 신속하고 정확하게 검사하여 디버깅 시간을 줄이고, 코드의 작은 변화가 의도한 대로 작동하는지 확인한다.
E2E테스트는 애풀리케이션의 중요한 사용자 흐름을 점검하여 배포 후 발생할 수 있는 치명적인 문제를 예방한다.

두 테스트를 함께 활용하면 애플리케이션의 안정성과 신뢰성을 극대화 할 수 있다.
</details>
<h2>React</h2>

<details>

<summary><strong>React에서 index를 key 값으로 사용하면 안되는 이유?</strong></summary>

배열의 요소들이 추가되거나 삭제될 때, 배열의 순서가 바뀌는 경우 문제가 발생할 수 있기 때문이다.

리액트는 key를 통해 리스트에서 어떤 요소가 변경, 추가, 삭제되었는지 추적하며, index를 key로 사용하면 배열의 순서가 변경될 때 리액트가 요소들을 잘못 인식할 수 있기 때문이다. 리액트는 이를 새로운 요소로 인식해 불필요하게 재렌더링을 하거나, 요소의 상태를 잘못 처리할 수 있다.

따라서 데이터의 유일성을 보장하고 변하지 않는 값을 사용해야하며, 데이터베이스에서 제공하는 고유 ID를 사용하는 것이 일반적이다.

</details>

<details>
<summary><strong>useEffect와 useLayoutEffect의 차이점은?</strong></summary>

`useEffect`와 `useLayout` 모두 렌더링 후에 특정 작업을 수행하기 위해 사용되지만 실행되는 타이밍과 용도가 다르다.

`useEffect`는 렌더링이 완료되는 시점에 비동기적으로 실행된다. 화면이 실제로 사용자에게 그려진 후에 `useEffect`가 실행되는 방식이다. 보통 데이터를 가져오는 작업이나 이벤트 리스너 추가 등 렌더링 후에 화면에 직접적인 영향을 주지 않는 작업에 주로 사용된다.

`useLayoutEffect`는 렌더링 후 DOM이 업데이트 되기 직전 시점에 동기적(화면에 내용이 그려지기 전에 모든 레이아웃 관련 작업이 완료됨)으로 실행된다. DOM의 크기를 측정하거나 위치를 조정해야할 때 `useLayoutEffect`를 사용하면 즉각적으로 그 변경사항이 반영되어 화면 깜빡임이나 불필요한 재렌더링을 방지할 수 있다.

렌더링 후 실행되는 비동기 작업에는 `useEffect`가 적합하고 레이아웃 작업이나 DOM 조작과 같이 화면에 그려지기 전에 완료되어야 하는 작업에는 `useLayoutEffect`가 적합하다.

`useLayoutEffect`는 동기적으로 실행되기 때문에 너무 많은 작업이 실행되면 렌더링이 느려질 수 있다. 보통은 `useEffect`를 사용하고 화면에 영향을 주는 작업만 `useLayoutEffect`로 처리하는 것이 좋다.
</details>

## CSS

<details>
<summary><strong>CSS Flexbox와 Grid의 차이
</strong></summary>

Flexbox와 Grid 모두 화면 요소를 배치하고 정렬하는 데 사용된다.

하지만 다음과 같은 차이점을 가지고 있다.
- Flexbox는 1차원 레이아웃 속성으로 row 또는 cloumn 중 하나를 기준으로 요소를 정렬하고 배치하는 데 최적화되어 있다.
주로 행이나 열 중 하나의 방향으로 정렬해야 할 때 유용하며, 복잡한 행과 열을 모두 포함하는 레이아웃에서는 다소 한계가 있다.

- Grid는 2차원 레이아웃 속성으로, 행과 열을 모두 사용해 요소를 배치할 수 있다. 따라서 복잡한 레이아웃을 구성하거나, 웹페이지의 전체적인 구조를 잡는 데 적합하다.

기본 동작에 대한 차이는 다음과 같다.

- Flexbox에서는 주로 요소가 컨테이너의 크기나 위치에 맞춰 자동으로 정렬된다. Flexbox의 justify-content,align-items 속성을 사용해, 주 축 방향으로 요소들을 배치하고 여백을 조절할 수 있다.
-Grid는 행과 열을 사전에 정의하고 그 격자에 요소를 배치하는 방식이다. grid-template-rows, grid-template-columns와 같은 속성으로 행과 열의 크기를 정의하고, 각 요소의 위치를 세밀하게 설정할 수 있다.

사용 목적의 차이는 다음과 같다.

- Flexbox는 컨텐츠 중심으로, 컨텐츠가 추가되거나 줄어들 때 유연하게 대처하기 좋다. 버튼 그룹, 내비게이션 바 등 한 줄의 컨텐츠가 주가 되는 구성에 적합하다.
- Grid는 레이아웃 중심으로 페이지 구조를 구성하는 데 최적화되어 있다. 카드 레이아웃, 갤러리 형식 등 명확하게 구분된 영역을 기반으로 레이아웃을 구성할 때 Grid가 효과적이다.

</details>